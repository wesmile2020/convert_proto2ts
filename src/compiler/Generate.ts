import { RESERVED_KEYWORDS } from './define';
import { getWhitespace, transformFieldType } from './helper';
import type { EnumNode, ExtendNode, ImportNode, MessageNode, ProtoFileNode } from '@/parser/ASTType';

export interface GenerateOptions {
  indentSize: number;
  pathResolver: (path: string) => string;
}

const defaultOptions: GenerateOptions = {
  indentSize: 2,
  pathResolver: (path: string) => path,
};

export class Generate {
  private static readonly reservedKeywords = new Set(RESERVED_KEYWORDS);

  private _indent: number = 0;
  private _options: GenerateOptions;
  private _ast: ProtoFileNode;
  private _output: string[] = [];

  constructor(ast: ProtoFileNode, options: Partial<GenerateOptions>) {
    this._ast = ast;
    this._options = { ...defaultOptions, ...options };
  }

  private _addLine(line: string) {
    this._output.push(`${getWhitespace(this._indent)}${line}`);
  }

  private _generateImport(node: ImportNode) {
    const importPath = this._options.pathResolver(node.path.value);
    this._addLine(`import '${importPath}';`);
  }

  private _generateEnum(node: EnumNode) {
    let enumName = node.name.value;
    if (Generate.reservedKeywords.has(enumName)) {
      enumName = `${enumName}_`;
    }
    this._addLine(`export enum ${enumName} {`);
    this._indent += this._options.indentSize;
    for (let i = 0; i < node.fields.length; i += 1) {
      const field = node.fields[i];
      this._addLine(`${field.name.value} = ${field.value.value},`);
    }
    this._indent -= this._options.indentSize;
    this._addLine(`}`);
  }

  private _generateExtend(node: ExtendNode) {
    let extendName = node.name.value;
    if (Generate.reservedKeywords.has(extendName)) {
      extendName = `${extendName}_`;
    }
    this._addLine(`export interface ${extendName} {`);
    this._indent += this._options.indentSize;
    for (let i = 0; i < node.fields.length; i += 1) {
      const field = node.fields[i];
      this._addLine(`${field.name.value}${transformFieldType(field)};`);
    }
    this._indent -= this._options.indentSize;
    this._addLine(`}`);
  }

  private _generateMessage(node: MessageNode) {
    let messageName = node.name.value;
    if (Generate.reservedKeywords.has(messageName)) {
      messageName = `${messageName}_`;
    }
    this._addLine(`export namespace ${messageName} {`);
    this._indent += this._options.indentSize;
    for (let i = 0; i < node.enums.length; i += 1) {
      this._generateEnum(node.enums[i]);
      this._output.push('');
    }
    for (let i = 0; i < node.messages.length; i += 1) {
      this._generateMessage(node.messages[i]);
      this._output.push('');
    }
    for (let i = 0; i < node.extends.length; i += 1) {
      this._generateExtend(node.extends[i]);
      this._output.push('');
    }
    this._indent -= this._options.indentSize;
    this._addLine('}\n');

    this._addLine(`export interface ${messageName} {`);
    this._indent += this._options.indentSize;
    for (let i = 0; i < node.fields.length; i += 1) {
      const field = node.fields[i];
      this._addLine(`${field.name.value}${transformFieldType(field)};`);
    }
    this._indent -= this._options.indentSize;
    this._output.push(`${getWhitespace(this._indent)}}`);
  }

  generate(): string {
    this._output.push('/** generated by convert_proto2ts, do not edit */\n');

    for (let i = 0; i < this._ast.imports.length; i += 1) {
      this._generateImport(this._ast.imports[i]);
    }
    this._output.push('');

    for (let i = 0; i < this._ast.enums.length; i += 1) {
      this._generateEnum(this._ast.enums[i]);
      this._output.push('');
    }
    
    for (let i = 0; i < this._ast.messages.length; i += 1) {
      this._generateMessage(this._ast.messages[i]);
      this._output.push('');
    }

    return this._output.join('\n');
  }
}
